using System.Collections.Immutable;
using Microsoft.CodeAnalysis;

namespace McpToolkit.Server.SourceGenerator;

partial class McpToolMethodGenerator
{
    static void EmitToolMethods(SourceProductionContext context, ImmutableArray<ToolContext> toolContexts)
    {
        var builder = new CodeBuilder(3);

        var toolMethodGroup = new List<(ToolMetadata Meta, string DelegateType)>();
        var toolNameSet = new HashSet<string>();

        foreach (var toolContext in toolContexts)
        {
            // check compilation errors
            if (toolContext.DiagnosticReporter.HasDiagnostics)
            {
                toolContext.DiagnosticReporter.ReportToContext(context);
                continue;
            }

            foreach (var meta in toolContext.MetadataList)
            {
                // check metadata is valid
                if (meta == null) continue;

                // check dupulicated tool name
                if (!toolNameSet.Add(meta.Name))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        DiagnosticDescriptors.DuplicateToolName,
                        meta.NameSyntaxLocation.Value,
                        meta.Name)
                    );
                    continue;
                }

                string delegateType;
                if (meta.ReturnType != null)
                {
                    if (meta.Parameters.Length == 0)
                    {
                        delegateType = $"Func<{meta.ReturnType}>";
                    }
                    else
                    {
                        delegateType = $"Func<{string.Join(", ", meta.Parameters.Array.Select(x => x.Type))}, {meta.ReturnType}>";
                    }
                }
                else
                {
                    if (meta.Parameters.Length == 0)
                    {
                        delegateType = $"Action";
                    }
                    else
                    {
                        delegateType = $"Action<{string.Join(", ", meta.Parameters.Array.Select(x => x.Type))}>";
                    }
                }

                toolMethodGroup.Add((meta, delegateType));
            }
        }

        foreach (var group in toolMethodGroup.GroupBy(x => x.DelegateType))
        {
            using var _1 = builder.BeginBlock($"public static void Add(this global::McpToolkit.Server.IMcpServerTools tools, string name, string? description, {group.Key} action)");
            using var _2 = builder.BeginBlock("switch (name)");

            foreach (var (meta, delegateType) in group.Distinct())
            {
                builder.AppendLine($"case \"{meta.Name}\":");
                using var _ = builder.BeginBlock();

                // Generate inputSchema
                var jsonParameters = meta.Parameters.Array.Where(x => !x.IsCancellationToken).ToArray();
                Emitter.EmitInputSchema(builder, jsonParameters, true);

                using (builder.BeginBlock("var tool = new global::McpToolkit.Tool()"))
                {
                    builder.AppendLine("Name = name,");
                    builder.AppendLine("Description = description,");
                    builder.AppendLine("InputSchema = inputSchema,");
                }
                builder.AppendLine(";");

                using (builder.BeginBlock($"tools.Add(tool, {(meta.IsAsync ? "async " : "")}(global::System.Text.Json.JsonElement? args, global::System.Threading.CancellationToken ct) =>"))
                {
                    Emitter.EmitHandlerBody(builder, jsonParameters, meta);
                }
                builder.AppendLine(");");

                builder.AppendLine("break;");
            }
        }

        var source =
$$"""
// <auto-generated/>
#nullable enable
#pragma warning disable

using System.Text.Json;

namespace McpToolkit.Server
{
    internal static partial class GeneratedMcpServerToolsExtensions
    {
{{builder}}
    }
}
""";

        context.AddSource($"GeneratedMcpServerToolsExtensions.Tools.g.cs", source);
    }
}