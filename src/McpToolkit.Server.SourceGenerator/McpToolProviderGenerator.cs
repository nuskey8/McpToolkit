using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace McpToolkit.Server.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class McpToolProviderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(static (node, ct) =>
            {
                return node is ClassDeclarationSyntax or RecordDeclarationSyntax;
            }, (context, ct) => context)
            .Select(static (context, ct) =>
            {
                var reporter = new DiagnosticReporter();
                var result = new ToolContext
                {
                    DiagnosticReporter = reporter,
                    Model = context.SemanticModel,
                };

                if (context.SemanticModel.GetDeclaredSymbol(context.Node) is not INamedTypeSymbol type)
                {
                    return result;
                }

                if (!type.GetMembers().Any(x => x.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::McpToolkit.McpToolAttribute")))
                {
                    return result;
                }

                if (type.IsStatic || type.IsAbstract)
                {
                    reporter.ReportDiagnostic(DiagnosticDescriptors.StaticOrAbstractNotAllowed, context.Node.GetLocation());
                    return result;
                }

                result.TypeSymbol = new(type);
                result.MetadataList = Parser.ParseFromClass(type!, (TypeDeclarationSyntax)context.Node, null!, reporter);

                return result;
            });

        context.RegisterSourceOutput(provider, Emit);
    }

    static void Emit(SourceProductionContext context, ToolContext toolContext)
    {
        if (toolContext.MetadataList.Count(x => x != null) == 0) return;

        var builder = new CodeBuilder(0);
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("#pragma warning disable");
        builder.AppendLine();
        builder.AppendLine("using System.Linq;");
        builder.AppendLine("using System.Text.Json;");
        builder.AppendLine();

        var type = toolContext.TypeSymbol.Value!;

        var ns = type.ContainingNamespace;
        CodeBuilder.Block? nsBlock = null;
        if (!ns.IsGlobalNamespace)
        {
            builder.AppendLine($"namespace {ns}");
            nsBlock = builder.BeginBlock();
        }

        var typeDeclarationKeyword = (type.IsRecord, type.IsValueType) switch
        {
            (true, true) => "record struct",
            (true, false) => "record",
            (false, true) => "struct",
            (false, false) => "class",
        };

        using (builder.BeginBlock($"partial {typeDeclarationKeyword} {type.Name} : global::McpToolkit.IMcpToolProvider"))
        {
            using (builder.BeginBlock("global::McpToolkit.ToolDescriptor[] global::McpToolkit.IMcpToolProvider.GetToolDescriptors(global::System.IServiceProvider serviceProvider)"))
            {
                using (builder.BeginBlock("return new global::McpToolkit.ToolDescriptor[]"))
                {
                    foreach (var meta in toolContext.MetadataList)
                    {
                        if (meta == null) continue;

                        using (builder.BeginBlock("new()"))
                        {
                            var jsonParameters = meta.Parameters.Array.Where(x => !x.IsCancellationToken).ToArray();

                            using (builder.BeginBlock("Tool = new()"))
                            {
                                builder.AppendLine($"Name = \"{meta.Name}\",");
                                builder.AppendLine($"Description = \"{meta.Description}\",");
                                builder.AppendLine($"InputSchema = ");
                                Emitter.EmitInputSchema(builder, jsonParameters, false);
                                builder.AppendLine(",");
                            }
                            builder.AppendLine(",");
                            using (builder.BeginBlock($"Handler = {(meta.IsAsync ? "async " : "")}(global::System.Text.Json.JsonElement? args, global::System.Threading.CancellationToken ct) =>"))
                            {
                                Emitter.EmitHandlerBody(builder, jsonParameters, meta);
                            }
                            builder.AppendLine(",");
                        }
                        builder.AppendLine(",");
                    }
                }
                builder.AppendLine(";");
            }

            if (nsBlock != null)
            {
                nsBlock.Value.Dispose();
            }
        }

        var fullType = type.ToDisplayString()
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        context.AddSource($"{fullType}.McpToolProvider.g.cs", builder.ToString());
    }
}