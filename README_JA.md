# MCP Toolkit for .NET
Lightweight, fast, NativeAOT compatible MCP (Model Context Protocol) framework for .NET

![header](./docs/header.png)

[![NuGet](https://img.shields.io/nuget/v/McpToolkit.svg)](https://www.nuget.org/packages/McpToolkit)
[![Releases](https://img.shields.io/github/release/nuskey8/McpToolkit.svg)](https://github.com/nuskey8/McpToolkit/releases)
[![license](https://img.shields.io/badge/LICENSE-MIT-green.svg)](LICENSE)

[English](./README.md) | 日本語

MCP Toolkit for .NETは.NETでMCP(Model Context Protocol)サーバー/クライアントを構築するためのフレームワークです。Source Generatorを活用した設計により、最小限のC#コードでMCPサーバー/クライアントを作成することが可能になります。

```cs
using McpToolkit;
using McpToolkit.Server;

await using var server = new McpServer();

server.Tools.Add("add", "Add two numbers together.", (double lhs, double rhs) =>
{
    return lhs + rhs;
});

await server.ConnectAsync(new StdioServerTransport());
await Task.Delay(Timeout.Infinite);
```

> [!CAUTION]
> MCP Toolkit for .NETは現在アルファ版であり、予告なく破壊的変更が行われる可能性があります。また、以下の機能は現在作業が進行中であり、対応したAPIが提供されていません。
> 
> * Streamable HTTP Transport
> * Authorization
> * Cancellation
> * Progress
> * Logging

## Why not C# SDK?

Model Context Protocolにはすでに[公式のC# SDK](https://github.com/modelcontextprotocol/csharp-sdk)が提供されています。ではなぜこのMCP Toolkitを利用するのでしょうか？

### Clear and Easy to Use API

MCP ToolkitはSource Generatorを全面的に活用し、直感的で扱いやすいAPIの提供に重点を置いています。以下はC# SDKとMCP Toolkitで同様のMCPサーバーを実装したコードの比較です。

```cs
// C# SDK
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.Server;
using System.ComponentModel;

var builder = Host.CreateApplicationBuilder(args);

builder.Services
    .AddMcpServer()
    .WithStdioServerTransport()
    .WithToolsFromAssembly();

await builder.Build().RunAsync();

[McpServerToolType]
public static class EchoTool
{
    [McpServerTool, Description("Echoes the message back to the client.")]
    public static string Echo(string message) => $"hello {message}";
}
```

```cs
// MCP Toolkit for .NET
using McpToolkit;
using McpToolkit.Server;

await using var server = new McpServer();

server.Tools.Add("echo",
    "Echoes the message back to the client.",
    (string message) => $"hello {message}");

await server.ConnectAsync(new StdioServerTransport());
await Task.Delay(Timeout.Infinite);
```

MCP Toolkitでは`server.Tools.Add()`の引数のラムダ式を解析し、必要なソースコードを生成します。もちろんC# SDK同様にクラス単位でのToolの追加にも対応しています。

### Zero Dependency

C# SDKが`Microsoft.Extensions.AI`および`Microsoft.Extensions.Hosting`に依存しているのに対し、MCP Toolkitは外部ライブラリに一切依存していません。

MCPはLLMとアプリケーションを統合するためのプロトコルですが、MCPそのものは単純なJSON-RPCであり、LLMに直接関連した機能は保持していません。そのため単純なMCPサーバーの実装であれば`Microsoft.Extensions.AI`の機能は不要であり、不必要な依存であると考えます。

また、`Microsoft.Extensions.Hosting`との統合はMCP Toolkitではオプションであり、拡張パッケージとして提供されています。`Microsoft.Extensions.Hosting`は巨大なパッケージであり、これへの依存は特にNative AOTにおいてバイナリサイズの増加につながります。Generic HostはWebアプリケーションの実装には強力ですが、ローカルで動作するMCPサーバー/クライアントの実装には必須ではありません。

### NativeAOT Compatible

MCP Toolkitは動的なコード生成を一切行わないため、Native AOTに完全に対応しています。これによりAOTコンパイルを利用したバイナリサイズや起動時間の削減を行うことが可能になります。

## 要件

MCP Toolkitを利用するには.NET 8以上が必要です。必要なパッケージは全てNuGetから入手できます。

## Getting Started (Server)

### インストール

MCPサーバーの実装を行うには`McpToolkit.Server`パッケージが必要です。

#### .NET CLI

```
dotnet add package McpToolkit.Server
```

#### Package Manager

```ps1
Install-Package McpToolkit.Server
```

### クイックスタート

`McpServer`を用いてMCPサーバーを簡単に実装できます。

```cs
await using var server = new McpServer
{
    Name = "Sample",
    Version = "1.0.0",
};

// Toolの追加
server.Tools.Add("foo", "Sample tool.", (string message) =>
{
    return $"test message: {message}";
});

// stdioをTransportに利用
await server.ConnectAsync(new StdioServerTransport());

// Clientからのリクエストを待機
await Task.Delay(TimeSpan.Infinite);
```

### Tool

`server.Tools.Add()`を用いてToolの追加を行うことができます。

```cs
// Toolの追加
server.Tools.Add("add", "Add two numbers together.", (double lhs, double rhs) =>
{
    return lhs + rhs;
});
```

MCP ToolkitのSource Generatorは`Tools.Add()`のラムダ式を解析し、適切なオーバーロードを生成します。

<details>

<summary>生成されたコード</summary>

```cs
// <auto-generated/>
#nullable enable
#pragma warning disable

using System.Text.Json;

namespace McpToolkit.Server
{
    internal static partial class GeneratedMcpServerToolsExtensions
    {
        public static void Add(this global::McpToolkit.Server.IMcpServerTools tools, string name, string? description, Func<double, double, double> action)
        {
            switch (name)
            {
                case "add":
                {
                    var inputSchema = global::System.Text.Json.JsonDocument.Parse(
                    """
                    {
                        "type": "object",
                        "properties": {
                            "lhs": {
                                "type": "number"
                            },
                            "rhs": {
                                "type": "number"
                            }
                        },
                        "required": ["lhs", "rhs"]
                    }
                    """).RootElement;

                    var tool = new global::McpToolkit.Tool()
                    {
                        Name = name,
                        Description = description,
                        InputSchema = inputSchema,
                    };

                    tools.Add(tool, (global::System.Text.Json.JsonElement? args, global::System.Threading.CancellationToken ct) =>
                    {
                        if (args == null)
                        {
                            throw new global::McpToolkit.McpException("Missing required argument 'lhs'");
                        }
                        var lhs = args.Value!.GetProperty("lhs").Deserialize<double>();
                        var rhs = args.Value!.GetProperty("rhs").Deserialize<double>();
                        return new([(action(lhs, rhs)).ToString()]);
                    });

                    break;
                }
            }
        }

    }
}
```

</details>

また、クラスのメソッドをまとめて登録することも可能です。メソッドを用いてツールを追加する場合、メソッドのドキュメントコメントの`<summary>`および`<param>`の情報から`description`が自動的に生成されます。

```cs
server.Tools.Add<Tools>();

partial class Tools
{
    /// <summary>
    /// Add two numbers together.
    /// </summary>
    /// <param name="lhs">left-hand side </param>
    /// <param name="rhs">right-hand side </param>
    [McpTool("add")]
    double Add(double lhs, double rhs)
    {
        return lhs + rhs;
    }
}
```


<details>

<summary>生成されたコード</summary>

```cs
// <auto-generated/>
#nullable enable
#pragma warning disable

using System.Text.Json;

partial class Tools : global::McpToolkit.IMcpToolProvider
{
    global::McpToolkit.ToolDescriptor[] global::McpToolkit.IMcpToolProvider.GetToolDescriptors(global::System.IServiceProvider serviceProvider)
    {
        return new global::McpToolkit.ToolDescriptor[]
        {
            new()
            {
                Tool = new()
                {
                    Name = "add",
                    Description = "Add two numbers together.",
                    InputSchema =  global::System.Text.Json.JsonDocument.Parse(
                    """
                    {
                        "type": "object",
                        "properties": {
                            "lhs": {
                                "type": "number",
                                "description": "left-hand side"
                            },
                            "rhs": {
                                "type": "number",
                                "description": "right-hand side"
                            }
                        },
                        "required": ["lhs", "rhs"]
                    }
                    """).RootElement,
                },
                Handler = (global::System.Text.Json.JsonElement? args, global::System.Threading.CancellationToken ct) =>
                {
                    if (args == null)
                    {
                        throw new global::McpToolkit.McpException("Missing required argument 'lhs'");
                    }
                    var lhs = args.Value!.GetProperty("lhs").Deserialize<double>();
                    var rhs = args.Value!.GetProperty("rhs").Deserialize<double>();
                    return new([(Add(lhs, rhs)).ToString()]);
                },
            },
        };
    }
}
```

</details>

ただし、Toolの引数はプリミティブ型、`DateTime`、任意の`Enum`に限定されています。戻り値の型は任意ですが、`Content[]`以外の場合は自動的に文字列に変換されます。より複雑な処理を行いたい場合は、後述する低レベルAPIを利用してください。

### Resource

`server.Resources.Add()`を用いてResourceを追加できます。

```cs
server.Resources.Add("file:///project/src/Program.cs",
    "Primary application entry point",
    async (uri, ct) =>
    {
        return [new()
        {
            Uri = uri,
            Text = await File.ReadAllTextAsync(uri.Replace("file://", ""), ct),
        }];
    });
```

### Prompts

`server.Prompts.Add()`を用いてPromptを追加できます。

```cs
server.Prompts.Add(new Prompt()
{
    Name = "review_code",
    Description = "Asks the LLM to analyze code quality and suggest improvements",
    Arguments = [new() { Name = "code", Description = "The code to review", Required = true }]
}, async (arguments, ct) =>
{
    var code = arguments!.Value.GetProperty("code").GetString();
    return [new() { Role = Role.User, Content = $"Please review the following code:\n{code}" }];
});
```

## Getting Started (Client)

### インストール

MCPクライアントの実装を行うには`McpToolkit.Client`パッケージが必要です。

#### .NET CLI

```
dotnet add package McpToolkit.Client
```

#### Package Manager

```ps1
Install-Package McpToolkit.Client
```

### クイックスタート

`McpClient`を用いてMCPクライアントを実装できます。

```cs
using McpToolkit.Client;

await using var client = new McpClient();

await client.ConnectAsync(new StdioClientTransport()
{
    Command = "dotnet",
    Arguments = "run --project ../ExampleServer/ExampleServer.csproj",
});

await foreach (var tool in client.Tools.ListAsync())
{
    Console.WriteLine(tool);
}

var results = await client.Tools.CallAsync("add", new
{
    lhs = 1,
    rhs = 2,
});

foreach (var result in results)
{
    Console.WriteLine(result.Text);
}
```

## Transport

`IMcpTransport`を実装することでTransport層を任意の実装に置き換えることができます。

> [!NOTE]
> 現在、Streamable HTTP Transportは提供されていません。これはv1.0.0までに実装される予定です。

```cs
public interface IMcpTransport : IAsyncDisposable
{
    bool IsConnected { get; }
    void SetRequestHandler(string method, Func<JsonRpcRequest, CancellationToken, ValueTask<JsonRpcResponse>> handler);
    void SetNotificationHandler(string method, Func<JsonRpcNotification, CancellationToken, ValueTask> handler);
    ValueTask StartAsync(CancellationToken cancellationToken = default);
    ValueTask SendMessageAsync(JsonRpcMessage message, CancellationToken cancellationToken = default);
    ValueTask<JsonRpcResponse> SendRequestAsync(JsonRpcRequest request, CancellationToken cancellationToken = default);
}
```

### Standard Input/Output (stdio)

```cs
// Server
await using var server = new McpServer();
await server.ConnectAsync(new StdioServerTransport());

// Client
await using var client = new McpClient();
await client.ConnectAsync(new StdioClientTransport()
{
    Command = "dotnet",
    Arguments = "run --project ../ExampleServer/ExampleServer.csproj",
});
```

### In-memory

```cs
await using var server = new McpServer();
await using var client = new McpClient();

var (serverTransport, clientTransport) = InMemoryTransport.CreateLinkedPair();
await server.ConnectAsync(serverTransport);
await client.ConnectAsync(clientTransport);
```

## 低レベルAPI

サーバー/クライアントの両方で`SetRequestHandler()`や`SetNotificationHandler()`を用いたより細かいカスタマイズが可能です。これはデフォルトのハンドラを置き換えることに注意してください。

```cs
await using var server = new McpServer();

server.SetRequestHandler(RequestSchema.ListToolsRequest, async (requestParams, ct) =>
{
    return new ListToolsResult
    {
        Tools = [
            new()
            {
                Name = "add",
                InputSchema = JsonSerializer.SerializeToElement(new
                {
                    type = "object",
                    properties = new
                    {
                        lhs = new { type = "number" },
                        rhs = new { type = "number" },
                    }
                })
            }
        ]
    };
});
```

## ライセンス

このライブラリは[MIT License](./LICENSE)の下で公開されています。